// Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:157-243
// Original: class TSLPatcherINISerializer: ...
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using CSharpKOTOR.Mods.GFF;
using CSharpKOTOR.Mods.SSF;
using CSharpKOTOR.Mods.TLK;
using CSharpKOTOR.Mods.TwoDA;

namespace CSharpKOTOR.Mods
{
    // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:91-120
    // Original: def escape_ini_value(value: str) -> str: ...
    public static class IniEscape
    {
        public static string EscapeIniValue(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return value;
            }

            // Escape backslashes first
            value = value.Replace("\\", "\\\\");

            // Escape newlines and carriage returns
            value = value.Replace("\r\n", "\\n");
            value = value.Replace("\n", "\\n");
            value = value.Replace("\r", "\\r");

            // Escape tabs
            value = value.Replace("\t", "\\t");

            return value;
        }
    }

    // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:157-243
    // Original: class TSLPatcherINISerializer: ...
    public class TSLPatcherINISerializer
    {
        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:160-173
        // Original: @staticmethod def _format_ini_value(...): ...
        private static string FormatIniValue(object value)
        {
            string valueStr = value?.ToString() ?? "";
            if (valueStr.Contains("'"))
            {
                return $"\"{valueStr}\"";
            }
            return valueStr;
        }

        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:175-242
        // Original: def serialize(...): ...
        public string Serialize(
            ModificationsByType modificationsByType,
            bool includeHeader = true,
            bool includeSettings = false,
            bool verbose = true)
        {
            var lines = new List<string>();

            // Add header comment
            if (includeHeader)
            {
                lines.AddRange(GenerateHeader());
            }

            // Add [Settings] section if requested
            if (includeSettings)
            {
                lines.AddRange(GenerateSettings());
            }

            // Order matters per TSLPatcher convention:
            // [TLKList], [InstallList], [2DAList], [GFFList], [CompileList], [SSFList]
            lines.AddRange(SerializeTlkList(modificationsByType.Tlk, verbose));
            lines.AddRange(SerializeInstallList(modificationsByType.Install, verbose));
            lines.AddRange(Serialize2DaList(modificationsByType.Twoda, verbose));
            lines.AddRange(SerializeGffList(modificationsByType.Gff, verbose));
            lines.AddRange(SerializeSsfList(modificationsByType.Ssf, verbose));
            // TODO: Add HACKList (NCS) serialization

            return string.Join("\n", lines);
        }

        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:244-289
        // Original: def _generate_header(self) -> list[str]: ...
        private List<string> GenerateHeader()
        {
            string today = DateTime.UtcNow.ToString("MM/dd/yyyy");
            return new List<string>
            {
                "; ============================================================================",
                $";  TSLPatcher Modifications File — Generated by HoloPatcher.NET ({today})",
                "; ============================================================================",
                ";",
                ";  This file is part of the HoloPatcher.NET ecosystem",
                ";",
                ";  FORMATTING NOTES:",
                ";    • This file is TSLPatcher-compliant and machine-generated.",
                ";    • You may add blank lines between sections (for readability).",
                ";    • You may add comment lines starting with semicolon.",
                ";    • Do NOT add blank lines or comments inside a section (between keys).",
                "; ============================================================================",
                ""
            };
        }

        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:291-297
        // Original: def _generate_settings(self) -> list[str]: ...
        private List<string> GenerateSettings()
        {
            return new List<string>
            {
                "[Settings]",
                "LogLevel=3",
                ""
            };
        }

        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:842-918
        // Original: def _serialize_tlk_list(...): ...
        private List<string> SerializeTlkList(List<ModificationsTLK> modifications, bool verbose)
        {
            if (modifications == null || modifications.Count == 0)
            {
                return new List<string>();
            }

            var lines = new List<string>();
            lines.Add("[TLKList]");

            // TODO: Implement full TLK serialization
            // For now, just add placeholder

            lines.Add("");
            return lines;
        }

        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:1100-1150
        // Original: def _serialize_install_list(...): ...
        private List<string> SerializeInstallList(List<InstallFile> installFiles, bool verbose)
        {
            if (installFiles == null || installFiles.Count == 0)
            {
                return new List<string>();
            }

            var lines = new List<string>();
            lines.Add("[InstallList]");

            // Group by destination folder
            var byFolder = installFiles.GroupBy(f => f.Destination ?? "Override");

            foreach (var folderGroup in byFolder)
            {
                string folder = folderGroup.Key;
                foreach (var installFile in folderGroup)
                {
                    string filename = !string.IsNullOrEmpty(installFile.SaveAs) 
                        ? installFile.SaveAs 
                        : installFile.SourceFile;
                    lines.Add($"File{lines.Count - 1}={filename}");
                    lines.Add($"  !Destination={folder}");
                    if (installFile.ReplaceFile)
                    {
                        lines.Add($"  !ReplaceFile=1");
                    }
                }
            }

            lines.Add("");
            return lines;
        }

        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:299-363
        // Original: def _serialize_2da_list(...): ...
        private List<string> Serialize2DaList(List<Modifications2DA> modifications, bool verbose)
        {
            if (modifications == null || modifications.Count == 0)
            {
                return new List<string>();
            }

            var lines = new List<string>();
            lines.Add("[2DAList]");

            for (int idx = 0; idx < modifications.Count; idx++)
            {
                var mod2da = modifications[idx];
                lines.Add($"Table{idx}={mod2da.SourceFile}");
            }
            lines.Add("");

            // Generate each 2DA file's sections
            foreach (var mod2da in modifications)
            {
                lines.AddRange(Serialize2DaFile(mod2da));
            }

            return lines;
        }

        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:330-363
        // Original: def _serialize_2da_file(...): ...
        private List<string> Serialize2DaFile(Modifications2DA mod2da)
        {
            var lines = new List<string>();
            lines.Add($"[{mod2da.SourceFile}]");

            // TODO: Implement full 2DA modifier serialization
            // This should serialize ChangeRow2DA, AddRow2DA, AddColumn2DA modifiers

            lines.Add("");
            return lines;
        }

        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:520-652
        // Original: def _serialize_gff_list(...): ...
        private List<string> SerializeGffList(List<ModificationsGFF> modifications, bool verbose)
        {
            if (modifications == null || modifications.Count == 0)
            {
                return new List<string>();
            }

            var lines = new List<string>();
            lines.Add("[GFFList]");

            for (int idx = 0; idx < modifications.Count; idx++)
            {
                var modGff = modifications[idx];
                string prefix = modGff.ReplaceFile ? "Replace" : "File";
                lines.Add($"{prefix}{idx}={modGff.SourceFile}");
            }
            lines.Add("");

            // Generate each GFF file's sections
            foreach (var modGff in modifications)
            {
                lines.AddRange(SerializeGffFile(modGff));
            }

            return lines;
        }

        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:554-652
        // Original: def _serialize_gff_file(...): ...
        private List<string> SerializeGffFile(ModificationsGFF modGff)
        {
            var lines = new List<string>();
            lines.Add($"[{modGff.SourceFile}]");

            lines.Add($"!ReplaceFile={(modGff.ReplaceFile ? "1" : "0")}");
            if (modGff.Destination != "Override")
            {
                lines.Add($"!Destination={FormatIniValue(modGff.Destination)}");
            }
            if (modGff.SaveAs != modGff.SourceFile)
            {
                lines.Add($"!Filename={FormatIniValue(modGff.SaveAs)}");
            }

            // TODO: Implement full GFF modifier serialization
            // This should serialize ModifyFieldGFF, AddFieldGFF, AddStructToListGFF, Memory2DAModifierGFF

            lines.Add("");
            return lines;
        }

        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:920-1000
        // Original: def _serialize_ssf_list(...): ...
        private List<string> SerializeSsfList(List<ModificationsSSF> modifications, bool verbose)
        {
            if (modifications == null || modifications.Count == 0)
            {
                return new List<string>();
            }

            var lines = new List<string>();
            lines.Add("[SSFList]");

            for (int idx = 0; idx < modifications.Count; idx++)
            {
                var modSsf = modifications[idx];
                string prefix = modSsf.ReplaceFile ? "Replace" : "File";
                lines.Add($"{prefix}{idx}={modSsf.SourceFile}");
            }
            lines.Add("");

            // Generate each SSF file's sections
            foreach (var modSsf in modifications)
            {
                lines.AddRange(SerializeSsfFile(modSsf));
            }

            return lines;
        }

        // Matching PyKotor implementation at vendor/PyKotor/Libraries/PyKotor/src/pykotor/tslpatcher/writer.py:952-1000
        // Original: def _serialize_ssf_file(...): ...
        private List<string> SerializeSsfFile(ModificationsSSF modSsf)
        {
            var lines = new List<string>();
            lines.Add($"[{modSsf.SourceFile}]");

            // TODO: Implement full SSF modifier serialization
            // This should serialize ModifySSF modifiers with sound names

            lines.Add("");
            return lines;
        }
    }
}

